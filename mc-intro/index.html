<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<html>
	<head>
		<title>Monte Carlo Integration</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });</script><span style="display:none">$$\newcommand{\n}{\hat{n}}\newcommand{\w}{\hat{\omega}}\newcommand{\wi}{\w_\mathrm{i}}\newcommand{\wo}{\w_\mathrm{o}}\newcommand{\wh}{\w_\mathrm{h}}\newcommand{\Li}{L_\mathrm{i}}\newcommand{\Lo}{L_\mathrm{o}}\newcommand{\Le}{L_\mathrm{e}}\newcommand{\Lr}{L_\mathrm{r}}\newcommand{\Lt}{L_\mathrm{t}}\newcommand{\O}{\mathrm{O}}\newcommand{\degrees}{{^{\large\circ}}}\newcommand{\T}{\mathsf{T}}\newcommand{\mathset}[1]{\mathbb{#1}}\newcommand{\Real}{\mathset{R}}\newcommand{\Integer}{\mathset{Z}}\newcommand{\Boolean}{\mathset{B}}\newcommand{\Complex}{\mathset{C}}\newcommand{\un}[1]{\,\mathrm{#1}}$$
		</span>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>		

		<link rel="stylesheet" type="text/css" href="../default.css">
	</head>

	<body>
		<div style="text-align: center;">
			<a href="../index.html">home</a>
			<a href="../blog/index.html">blog</a>
			<a href="../journal/index.html">journal</a>
			<a href="../learn/index.html">learn</a>
			<a href="../about.html">about</a>
		</div>
		<div id="markdeep_content">
<span class="md"><p><title>Monte Carlo Integration</title><div class="title"> Monte Carlo Integration </div>

<div class="subtitle"> Anders Lindqvist (<a href="https://twitter.com/anders_breakin">breakin</a>) </div>
<div class="afterTitles"></div><div class="shortTOC"><a href="#toc1">Variance</a> &middot; <a href="#toc2">Importance Sampling</a> &middot; <a href="#toc3">Multiple Importance Sampling</a> &middot; <a href="#toc4">Jittered Sampling</a> &middot; <a href="#toc5">References</a> &middot; <a href="#toc6">About</a></div>

</p><p>

<div class="admonition tip">This document is in excellent shape but it will be continually improved by me whenever I figure out new things I want to explain, or new ways of explaining it! I am proud of the content here so don't be afraid to read it, but do expect it to change form from time to time. Also note that the pseudo code sample doesn't (always) have numerically stable code. I've aimed for readability.</div>

</p><p>

<div class="admonition tip">There is an experimental interactive vizualizer for this article that can be accessed <a href="demo.html">here</a>. I doesn't support everything but you can at least see how importance sampling and jittering affects the samples.</div>

</p><p>

Monte Carlo Integration is a way to integrate a function when it isn't feasible to integrate it analytically. Here I will try to show how it works using 1D-functions but the method itself works in any dimension. This document is written to build intuition around Monte Carlo integration and it will not be super rigorous.

</p><p>

The function we are integrating will always be called \(f(x)\) and for this particular arbitrary function \(f\) the parameter \(x\) is defined on the interval \([0,\pi]\).

</p><p>

<center><div class="image" style=""><a  href="images/mc_f.svg" target="_blank"><img class="markdeep" src="images/mc_f.svg" /></a ><div class="imagecaption">Our function. Integral we are seeking is the area below the curve.</div></div></center>

</p><p>

Now the integral is simply the area below the curve. The idea here is that while we can easily evaluate \(f(x)\) by evaluating it pointwise we don't have access to a simple expression for \(f(x)\) that we can integrate. This is usually because \(f\) is not a simple function (as in an analytic function) but rather an involved procedure that returns a value for each \(x\).

</p><p>

First let us pretend that we want to find the integral of \(f(x)\) on many machines but we are only allowed to evaluate \(f(x)\) once on each machine. Today many will mean 5 to make it easier to create figures! What do we do? One thing we can do is to divide the x-interval into 5 pieces (<em class="asterisk">cells</em>) and let each machine estimate the integral within their cell somehow. Then we sum up the 5 integrals from the 5 cells to find the total integral (the area under the entire curve).

</p><p>

<center><div class="image" style=""><a  href="images/mc_f_bars5.svg" target="_blank"><img class="markdeep" src="images/mc_f_bars5.svg" /></a ><div class="imagecaption">Function (and integral split) into 5 cells.</div></div></center>

</p><p>

How should each machine evaluate \(f(x)\) within its cell then? It seems that we are back at our original problem. Let us ignore that for a while and continue. One alternative would be to place a sample in the middle of the cell and multiple by the width of the cell. That leaves us with a rectangle approximating the integral for each cell. The height of the rectangle is given by \(f(x)\) for the x-value at the middlepoint of the cell. The answer would not be correct but at least we are not trying to approximate the full function with a single rectangle. If we added more machines it would become more and more accurate. The integral from each cell would be equal to the area of the rectangle instead of the integral of \(f(x)\) itself.

</p><p>

<center><div class="image" style=""><a  href="images/mc_f_barsample.svg" target="_blank"><img class="markdeep" src="images/mc_f_barsample.svg" /></a ><div class="imagecaption">Sample in middle of cells, rectangles are our approximation of integral in cell.</div></div></center>

</p><p>

But what if a friend comes along and she let us know that she has tried the same thing on her 5 machines? It would be nice if we could somehow &ldquo;merge&rdquo; our result with her result. But that is not possible if we both have the same value for the integral! Calculating the integral twice didn't improve the estimate. If we had synced this experiment first we could have split the function into 10 pieces and calculated half each and then summed up. But is there another way to do this without talking first? Or maybe we found out that doing 5 estimates was faster then we anticipated so we have time for 5 more. Where do we place them such that we can improve on our previous result? In an ideal world we would get an early estimate of the real value and then as time goes by we can refine the estimate until either the world ends or we end up with the true value of the integral.

</p><p>

The problem with our current scheme seems to be that we always choose the point in the middle. If we instead choose a point at prob within each interval then our estimates of the integral in that interval would be different each time. Lets take a step back. What if we had no intervals at all, just the entire function to estimate with some samples. Would placing them probly work out? For this to make sense we must shrink the width of the samples the more samples we take. Now I want to point out that estimating \(f(x)\) in one of our five intervals is really the same as estimating it in the entire interval (it is just integral estimation) so lets go back to estimating the full integral and not just one little piece. Our progressive (which here means gradually improving over time) estimates with random placed samples in \([0,\pi]\) then would be

</p><p>

\begin{eqnarray}
e_0 & = & \pi f(x_0) \\
e_1 & = & \frac{\pi}{2} (f(x_0)+f(x_1)) \\
e_2 & = & \frac{\pi}{3} (f(x_0)+f(x_1)+f(x_2)) \\
e_3 & = & ...
\end{eqnarray}

</p><p>

where \(x_i\) would be chosen totally prob. Here the factor \(\pi\) comes from the range of x-values so it is not a magical \(\pi\) that should appear just because it is monte carlo integration. This is the same as what we did before, only that our \(x\) values were placed evenly then. This newer formulation is very handy in that we don't have to decide how many samples we need before we start. If we get more time we can do more. We can merge results from different computers easily by summing them (applying weights it the machines has done a different amount of samples) etc. We can gladly take the result from our friend and merge it in.

</p><p>

This thing that we have concocted here is called a Monte Carlo estimator. The property that we can add together different estimates makes this estimator <em class="asterisk">unbiased</em>. The estimator we did first placing the samples in the middle of the intervals was <em class="asterisk">biased</em>. We need an unbiased estimator to be able to add together different estimates to get a better estimate.

</p><p>

Note that if we have taken 12 samples and our friend only 3 samples then the estimates should be weighted properly such that more weight is given to our better estimate.

</p><p>

At this point I want to write out the general formula of the estimator. It rewrites the \(\frac{\pi}{N}\)-term as \(p(x)\) where \(p(x)\) represent the probability to choose a particular x-value. If we choose the x-values uniformly (probly and evenly) \(p(x)\) will be constant (and equal to \(\frac{\pi}{N}\) in our example above for an estimate with \(N\) samples). When we look at importance sampling \(p(x)\) will no longer be constant.

</p><p>

The full formula then, using \(p(x)\), is

</p><p>

\begin{equation}
F = \frac{1}{N} \sum_i^N \frac{f(x_i)}{p(x_i)}
\end{equation}
where \(x_i\) are out x-values, \(f\) is the function we want to integrate, \(p\) is the probability distribution function that says how often we choose a \(x\)-value and \(N\) is the number of x-values. \(F\) is a single value representing the integral of \(f\) (which is a function). Note that it is just an approximation of the true integral.

</p>
<a class="target" name="variance">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Variance</h1>
<p>


A section on variance is sorely missing. For now think of the variance of our estimate as how noisy it is. There are bounds on how fast the variance decreases as we take more samples. Stay tuned!

</p>
<a class="target" name="importancesampling">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Importance Sampling</h1>
<p>


The core idea of importance sampling is that if we divide our function into many small parts (like we did before into 5 intervals) we should spend more effort getting the answer right in the intervals where the integral is large. So lets make those intervals wider!

</p><p>

<center><div class="image" style=""><a  href="images/mc_is_bars.svg" target="_blank"><img class="markdeep" src="images/mc_is_bars.svg" /></a ><div class="imagecaption">f(x) from introduction with adjusted intervals.</div></div></center>

</p><p>

Getting the answer 5% wrong in an interval where the true integral value is 0.1 is not as bad as getting it 5% wrong in an interval where the true integral value is 100.

</p><p>

Now we can divide it even further into say 1000 pieces and apply the same reasoning. Or we can do it using actual importance sampling where we do it in a continous fashion. We have a probability distribution function \(p(x)\) that gives probability density for a given value \(x\).

</p><p>

Now to complicate things we often don't actually know \(f(x)\) analytically. We might know a part of it or we have some sort of upper or lower bound on it. In path tracing it is quite common that we have that \(f(x)\) is a product of a few different functions and we might know the properties of one or two of them. Sometimes we know all the components but it is impractical to figure out the proper widths of the intervals. This is often the case when the dimensionality is high.

</p><p>

We realize that if we fail to guess at the size of \(f\) we might make things worse. The expression \(\frac{f(x)}{p(x)}\) in our monte carlo estimator might give very high values for some \(x\) due to the fact that we divide by \(p(x)\) that might be a very small number. This would be ok if \(f(x)\) was very small but if it isn't we are in a lot of trouble. This produces very high intensity noise that requires MANY samples to get rid of.

</p><p>

Some pseudo code:

</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">importance_sample_f</span><span class="hljs-params">(<span class="hljs-keyword">float</span> u, <span class="hljs-keyword">float</span> *p)</span> </span>{
	<span class="hljs-comment">// given a random value u in 0-1</span>
	<span class="hljs-comment">// return a x-value with prob p(x)</span>
	<span class="hljs-keyword">float</span> x = ...;
	*p = ...;
	<span class="hljs-keyword">return</span> x;
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">estimate_f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>{
  <span class="hljs-keyword">float</span> f = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-keyword">float</span> p;
    <span class="hljs-keyword">float</span> x = importance_sample_f(uniform(), &amp;p);
    f += eval_f(x)/p;
  }
  <span class="hljs-keyword">return</span> f/N;
}</code></pre><p>



<div class="admonition tip">If we know that our function \(f(x) <= g(x)*h(x)\) but we only can importance sample according to \(g(x)\) OR \(h(x)\) we can use multiple importance sampling to get the best of both worlds. If we somehow manage to sample according to \(g(x)*h(x)\) that is instead called product sampling.</div>

</p><p>

<div class="admonition tip">Constructing functions to importance sample is not trivial. Feel free to look at <a href="https://breakin.github.io/equations">my other document</a> that has a few examples!</div>

</p>
<a class="target" name="multipleimportancesampling">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Multiple Importance Sampling</h1>
<p>




<div class="admonition tip">First: Everything I write about here can be found in <a href="https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf">Veach thesis</a>. It is quite readable and I recommend it. My text here is trying to teach less in simpler terms.</div>

</p><p>

Lets say that we have a function \(f(x)\) that we want to integrate (find area under curve for)

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_product.svg" target="_blank"><img class="markdeep" src="images/mc_mis_product.svg" /></a ><div class="imagecaption">Function \(f(x)\) to integrate.</div></div></center>

</p><p>

Now in this example we don't actually have access to this function. Instead it is composed as the product of three terms, like \(f(x)=B(x)L(x)V(x)\). The two first terms, \(L(x)\) and \(B(x)\), have known analytical expressions and we can do importance sampling of those individually. It doesn't have to be optimal importance sampling. The third term \(V(x)\) is expensive to calculate but we know that all values are below 1.0 such that it can only make the product smaller.

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_parts.svg" target="_blank"><img class="markdeep" src="images/mc_mis_parts.svg" /></a ><div class="imagecaption">The components of \(f(x)\); \(L(x), B(x), V(x)\).</div></div></center>

</p><p>

<div class="admonition tip">Note that while the letters \(L,B,V\) here are arbitrary 1d-function I've modelled this example after path tracing. Here they stands for brdf (material), light and visibility. Note that since are in 1D I didn't bothered to normalize \(B\) properly. The principles carries over to other examples as well but then using two techniques like we do here might not be sufficient.</div>

</p><p>

If we remove \(V(x)\) from \(f(x)\) we get \(B(x)L(x)\) which is what we can hope to importance sample since \(V(x)\) has no analytical expression. First we assume that we are unable to actually do importance sampling according to \(B(x)L(x)\) which is often what happens as soon as we enter higher-dimensional functions (x is maybe three dimension and both B and L depends on many other parameters as well). Here we can see the function that want to importance sample somehow

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_product_nov.svg" target="_blank"><img class="markdeep" src="images/mc_mis_product_nov.svg" /></a ><div class="imagecaption">\(B(x)L(x)\).</div></div></center>

</p><p>

Note that we will still use the full function \(B(x)L(x)V(x)\), it just that we can't factor in \(V\) so we just have to hope that it won't mess up. Now lets first think about why standard importance sampling is a bad idea. First lets name the probability distribution functions \(p_B(x)\) and \(p_L(x)\) that says how often we pick a x-value when doing importance sampling according to \(B\) or \(L\). When we do monte carlo integration we must sometimes choose x values that are unlikely. We do so with a low probability and then, to stay unbiased, we must boost them. We do that by dividing by the probability of choosing that x-value. Dividing by a small number yields a big number. If we importance sample according to \(B(x)\) and hit a large value in \(L(x)\) there will be a boost. Here I've tried to graph the badness of sampling using improper importance sampling. What is pictures if \(\frac{f(x)}{p(x)}\) when using importance sampling with two different choices of \(p\)

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_prob_div.svg" target="_blank"><img class="markdeep" src="images/mc_mis_prob_div.svg" /></a ><div class="imagecaption">Boosting due to importance sampling when using \(p_B\) and \(p_L\).</div></div></center>

</p><p>

We see that the maximum value is quite big. When sampling using importance sampling based on \(L\) we sometimes get a very bright color (larger than 13) back. Same when are sampling according to \(B\). This makes us realize that importance sampling is best when either lighting is very flat (single color sky) or material is very smooth (diffuse). Otherwise we might get worse result from importance sampling compared to doing uniform sampling.

</p><p>

Anyway. Ok we are ready for MIS! These two methods, sampling according to \(L(x)\) and sampling according to \(B(x)\) are called <em class="asterisk">techniques</em> when it comes to MIS. For now we will stick to two techniques that we use equally much and try to build intution, but Veach thesis shows how this works for multiple techniques with an arbitrary amount of samples from each.

</p><p>

The idea now is to introduce two functions such that \(f(x)=f_L(x) + f_B(x)\). This is not a new \(f(x)\) but the same one we have been dealing with all along (\(B(x)L(x)V(x)\)). We estimate \(f_L\) and \(f_B\) individually using the two techniques and then we add together the two estimates. This means that \(f_B\) is sampled using importance sampling based on \(p_B\) and \(f_L\) with importance sampling based on \(p_L\). This will mean that the two methods will choose different x-values so the two estimates will not be based on evaluations at the same x-values (which is ok).

</p><p>

The idea here is to look at each x-value and see what technique would perform better. For each x-value we select a weight that says how much of each technique we should use. In the case of two techniques this can be thouhg of as a blending-factor (as in lerp). If they are equally good the factor will be 0.5. If one is superior lets go with 1.0 or 0.0 to choose one of the two techniques.

</p><p>

But for what x-values is a technique good? If a technique samples a x-value often it will get a good estimate at that x-value. If the other technique samples it less often they are less good. How often a technique samples a x-value is the probability function that we use as a base in order to do the importance sampling. So we already have it!

</p><p>

The weights then, as a function of x, becomes

</p><p>

\begin{eqnarray}
w_B(x) & = & \frac{p_B(x)}{p_L(x)+p_B(x)} \\
w_L(x) & = & \frac{p_L(x)}{p_L(x)+p_B(x)} \\
\end{eqnarray}

</p><p>

Note that the weights sum to 1 by construction
\begin{eqnarray}
w_B(x) + w_L(x) & = & 1
\end{eqnarray}

</p><p>

That gives us
\begin{eqnarray}
f_B(x) & = & w_B(x)f(x) = \\
 & = & \left(\frac{p_B(x)}{p_L(x)+p_B(x)}\right)f(x) \\
f_L(x) & = & w_L(x)f(x) =\\
 & = & \left(\frac{p_L(x)}{p_L(x)+p_B(x)}\right)f(x) \\
 f(x) & = & f_L(x)+f_B(x)
\end{eqnarray}

</p><p>

Before we vizualize I want to point out that even if we evaluate \(f_L\) and \(f_B\) on different computers they need to know about the other techniqe since both probabilities are needed in order to get the weighting factor.

</p><p>

Ok lets take a look at \(f_L\) and \(f_b\). First we need to normalize \(L\) and \(B\) so they become probability distribution functions:

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_prob.svg" target="_blank"><img class="markdeep" src="images/mc_mis_prob.svg" /></a ><div class="imagecaption">Probabilities</div></div></center>

</p><p>

Now we can use the formula for the weight based on the probabilities. This gives us the following very fun graph

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_weights.svg" target="_blank"><img class="markdeep" src="images/mc_mis_weights.svg" /></a ><div class="imagecaption">Weights</div></div></center>

</p><p>

Using this we can now vizualize \(f_L\) and \(f_B\)

</p><p>

<table width="100%"><tr valign="top"><td>

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_fb.svg" target="_blank"><img class="markdeep" src="images/mc_mis_fb.svg" /></a ><div class="imagecaption">\(f_B(x)\)</div></div></center>

</p><p>

</td><td>

</p><p>

 <center><div class="image" style=""><a  href="images/mc_mis_fl.svg" target="_blank"><img class="markdeep" src="images/mc_mis_fl.svg" /></a ><div class="imagecaption">\(f_L(x)\)</div></div></center>

</p><p>

</td></tr><tr valign="top"><td>

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_fb_nov.svg" target="_blank"><img class="markdeep" src="images/mc_mis_fb_nov.svg" /></a ><div class="imagecaption">\(f_B(x)\) without \(V(x)\)</div></div></center>

</p><p>

</td><td>

</p><p>

 <center><div class="image" style=""><a  href="images/mc_mis_fl_nov.svg" target="_blank"><img class="markdeep" src="images/mc_mis_fl_nov.svg" /></a ><div class="imagecaption">\(f_L(x)\) without \(V(x)\)</div></div></center>

</p><p>

</td></tr></table>

</p><p>

The two images on the left omit the influence of \(V(x)\) that we don't try to include in the importance sampling. Note that it is still part of \(f_B\) and \(f_L\), it is just that we have to let it do what it does since we know too little about it. If we add \(f_B\) and \(f_L\) together we get \(f(x)\) which is what we actually want to estimate. Here is a graph with \(f_L, f_B\) and \(f\) at the same time, just to show that they add up to \(f(x)\)

</p><p>

<table width="100%"><tr valign="top"><td>

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_fl_fb_sum.svg" target="_blank"><img class="markdeep" src="images/mc_mis_fl_fb_sum.svg" /></a ><div class="imagecaption">Sum of \(f_B\) and \(f_L\)</div></div></center>

</p><p>

</td><td>

</p><p>

 <center><div class="image" style=""><a  href="images/mc_mis_fl_fb_sum_nov.svg" target="_blank"><img class="markdeep" src="images/mc_mis_fl_fb_sum_nov.svg" /></a ><div class="imagecaption">Sum of \(f_B\) and \(f_L\) without \(V(x)\)</div></div></center>

</p><p>

</td></tr></table>

</p><p>

So there we have it. Two weird functions (\(f_B\) and \(f_L\)) that we evaluate using regular importance sampling and add together.

</p><p>

The idea then is that the two technique will importance sample these two functions properly. If a x-value is chosen say outside of a narrow peak in \(B(x)\) regular monte carlo integration would boost the result there since the probability is low and we divide by the probability. But here that will be limited since when \(B(x)\) is low it can be masked away (given that another technique is good enough).

</p><p>

As long as we have a technique that is good at sampling every \(x\) that techniques that are bad will be suppressed. It is possible to mix more than two techniques using the method outlined above. This will avoid situations where we sample low-probability events and boost them (in order to unbiased).

</p><p>

So why is it better to sample \(f_L\) and \(f_b\) then using their respective importance sampling methods compared to sampling \(f(x)\) directly using one of the importance sampling methods? Remember the earlier graph depicting \(\frac{f(x)}{p_L(x)}\). Now here then are the badness of our <em class="asterisk">two</em> estimators that we use with MIS. Did it improve? We see that the maximum boost value is much lower compared to the ones for using importance sampling using one of the two methods.

</p><p>

<center><div class="image" style=""><a  href="images/mc_mis_prob_div.svg" target="_blank"><img class="markdeep" src="images/mc_mis_prob_div.svg" /></a ><div class="imagecaption">Badness importance sampling \(f_B\) or \(f_L\) using \(p_B\) and \(p_L\).</div></div></center>

</p><p>

Note that the badness are the same for two techniques. This is because the probability in the denominator cancels out the probability in the weight. Recall that

</p><p>

\begin{eqnarray}
f_B(x) & = & \left(\frac{p_B(x)}{p_L(x)+p_B(x)}\right)f(x) \\
 f_L(x) & = & \left(\frac{p_L(x)}{p_L(x)+p_B(x)}\right)f(x)
\end{eqnarray}

</p><p>

so when we divide \(f_B\) by \(p_B(x)\) or \(f_L\) by \(p_L\) we end up with the same expression \(\frac{f(x)}{p_B(x)+p_L(x)}\). This shows that MIS is doing its job; the techniques collaborate. We only get boosting for \(x\) where both \(p_B(x)\) and \(p_L(x)\) is low. We no longer have the problem when using one of the two techniques.

</p><p>

We don't have a third technique to importance sample \(V(x)\) so \(V(x)\) might still mess things up. In our example \(V(x)<=1\) so it can't mess up too much. It won't boost but it can lead to the same issues as with regular importance where the only regions that are important when taking \(V(x)\) into account are poorly sampled by the importance sampling.

</p><p>

Summary: The MIS-estimator might have fewer samples but they will boost things less often. If we want to estimate \(f(x)\) using 16 samples we instead estimate \(f_L\) using 8 samples and \(f_B\) using 8 samples. We add the two together to get the full estimate.

</p><p>

The true beauty of this system comes when we use it. Then \(B,L,V\) might not be static functions that we can reason about. Instead they might change and combine in weird ways such that we can't really reason about the product of them. Then having MIS coming in magically and figuring out the weights for us can feel like magic.

</p><p>

Some pseudo-code that might help clarify!

</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">eval_f</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x)</span> </span>{
  <span class="hljs-comment">// The function we want to integrate</span>
  <span class="hljs-keyword">return</span> B(x)*L(x)*V(x);
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">importance_sample_pb</span><span class="hljs-params">(<span class="hljs-keyword">float</span> u, <span class="hljs-keyword">float</span> *prob)</span> </span>{
  <span class="hljs-comment">// Given random value return x-value</span>
  <span class="hljs-comment">// Importance sampled according to B(x)</span>
  <span class="hljs-comment">// Probability of choosing that x-value is written to prob</span>
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">importance_sample_pl</span><span class="hljs-params">(<span class="hljs-keyword">float</span> u, <span class="hljs-keyword">float</span> *prob)</span> </span>{
  <span class="hljs-comment">// Given random value return x-value</span>
  <span class="hljs-comment">// Importance sampled according to L(x)</span>
  <span class="hljs-comment">// Probability of choosing that x-value is written to prob</span>
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x)</span> </span>{
  <span class="hljs-comment">// Probability of choosing x when importance samling using B(x)</span>
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">pl</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x)</span> </span>{
  <span class="hljs-comment">// Probability of choosing x when importance samling using L(x)</span>
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">estimate_f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>{
  <span class="hljs-keyword">float</span> f = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-comment">// Tech 1 (sample pB)</span>
    <span class="hljs-keyword">float</span> prob_bb;
    <span class="hljs-keyword">float</span> xb = importance_sample_pb(uniform(), &amp;prob_bb);
    <span class="hljs-keyword">float</span> prob_bl = pl(xb);

    <span class="hljs-comment">// Tech 2 (sample pL)</span>
    <span class="hljs-keyword">float</span> prob_ll;
    <span class="hljs-keyword">float</span> xl = importance_sample_pl(uniform(), &amp;prob_ll);
    <span class="hljs-keyword">float</span> prob_lb = pb(xl);

    <span class="hljs-comment">// Sum</span>
    <span class="hljs-keyword">float</span> wb = prob_bb/(prob_bb+prob_bl);
    <span class="hljs-keyword">float</span> wl = prob_ll/(prob_ll+prob_lb);

    <span class="hljs-comment">// Note we eval f at two different places</span>
    f += eval_f(xb) * wb + eval_f(xl) * wl;
  }
  <span class="hljs-keyword">return</span> f/N;
}

<span class="hljs-comment">// Same as estimate_f, just written differently</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">estimate_f_variant</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>{
  <span class="hljs-keyword">float</span> f = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Tech 1 (sample pB)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-keyword">float</span> prob_bb;
    <span class="hljs-keyword">float</span> xb = importance_sample_pb(uniform(), &amp;prob_bb);
    <span class="hljs-keyword">float</span> prob_bl = pl(xb);
    <span class="hljs-keyword">float</span> wb = prob_bb/(prob_bb+prob_bl);
    f += eval_f(xb) * wb;
  }
  <span class="hljs-comment">// Tech 2 (sample pL)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-keyword">float</span> prob_ll;
    <span class="hljs-keyword">float</span> xl = importance_sample_pl(uniform(), &amp;prob_ll);
    <span class="hljs-keyword">float</span> prob_lb = pb(xl);
    <span class="hljs-keyword">float</span> wl = prob_ll/(prob_ll+prob_lb);
    f += eval_f(xl) * wk;
  }
  <span class="hljs-keyword">return</span> f/N;
}</code></pre>
<a class="target" name="misinthecontextofpathtracing">&nbsp;</a><a class="target" name="toc3.1">&nbsp;</a><h2>MIS In the Context of Path Tracing</h2>
<p>




<div class="admonition tip">This is a complicated subject and these notes will probably be moved elsewhere later. It doesn't belong in a beginners text on the subject but needs to be introduced alongside a path tracer.</div>

</p><p>

In order to build intution I will talk some about how this can be used in a path tracer. Perhaps it will help!

</p><p>

<ul>
<li class="asterisk">Each x-value above represent and incoming direction of light in this analogy. The function \(B\) depends on the outgoing direction (direction to camera for first bounce) as well as all material properties for this particular point we are standing at. X is not the position of the surface point, it is the incoming direction that we want to choose.
</li>
<li class="asterisk">In my first hobby path tracer (that I did with a friend that knew far more about it than me at the time!) we looked at the material properties (\(B(x)\)) to determine if we should sample according to \(L\) or \(B\). If the material was very spiky (roughness low or glossiness high as it was called back then) we choose the sample according to \(B\), otherwise we sampled according to \(L\). This was not a very good solution and it required a lot of tweaking.
</li>
<li class="asterisk">Shooting twice the amount of rays sounds bad but sometimes it comes mostly for free. If we shoot a ray toward an area light source we use the direct-technique. Then when we follow our indirect ray we do so according to brdf-importance sampling. If we ended up the area light then implicitly that is our indirect technique. The new hard thing is that we must be able to answer what probability other techniques would have done this to get the weighting factor.
</li>
<li class="asterisk">In importance sampling it is nice that probability and brdf factors cancels out, but in MIS you need to real probability so you can't always cancel stuff out. Might lead to more floating-point errors in some cases.
</li>
<li class="asterisk">In the case where you have a material with many components (diffuse, specular) you can choose one technique each time based on a prob choice (based on intensity of color or so). Veach calls this the one-sample model. If specular is chosen and you end up outside peak the diffuse model can help since they kinda collaborate.
</li>
<li class="asterisk">In the case of a area light and a narrow peak in the brdf (and then a long tail). For directions towards the area light source everything will end up in \(f_L\). For directions inside the brdf peak everything will end up in \(f_B\). If the brdf peak happens to look at the area light they will both help, at least for the directions are overlapping.
</li>
<li class="asterisk">When I talk about boosting something this is really what causes fireflies. When doing importance sampling with material BRDF well outside the main peak we have a low probability and if light shines there we will boost it a lot.
</li>
<li class="asterisk">If we have an area light you might think that sampling according to the light is good. But for very narrow specular lobes there might be very high valued samples somewhere on the surface of the area light. That spot is best sampled using the material brdf.
</li>
<li class="asterisk">When we break the rendering equation up into parts we might have a term that is contribution from a direct light source bounces by material into a direction. It is possible to write this integral over the surface/volume of the light source OR over incoming directions at the surface where we are doing our estimate. Both are valid and possible to estimate using monte carlo integration, but the \(p(x)\) used will be different. This is ok until we try to plug them into MIS. For MIS the probabilities must be with respect to the same thing to be efficient. Veach thesis talks about how to convert probabilities in last paragraphs of <a href="https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf">9.1.3</a> and <a href="https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter8.pdf">8.2.2.2</a>.</li></ul>

</p>
<a class="target" name="jitteredsampling">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Jittered Sampling</h1>
<p>


It turns out that dividing the full interval into smaller intervals and choosing a \(x\) value within each interval is actually a good idea. If we want to take 16 samples we divide the inteval into 16 pieces. This concept is called jittered sampling and it always has lower variance (noise) than doing pure uniform sampling. The downside is that we need to commit to a number of samples that we are going to take and take them all before we have an unbiased result. A form of jittering was described and patented by Pixar but as far as I know that patent has expired. Jittered sampling is good since it avoids clumping of samples. Samples can only clump together at the boundaries between intervals.

</p><p>

Imagine the following with one sample being placed randomly in each cell

</p><p>

<center><div class="image" style=""><a  href="images/mc_f_bars5.svg" target="_blank"><img class="markdeep" src="images/mc_f_bars5.svg" /></a ><div class="imagecaption">Function (and integral split) into 5 cells.</div></div></center>

</p><p>

Here is some pseudo ccode

</p><pre class="listing tilde"><code><span class="hljs-built_in">float</span> random_uniform() {
  // <span class="hljs-keyword">return</span> random <span class="hljs-keyword">number</span> between <span class="hljs-number">0.0</span> and <span class="hljs-number">1.0</span>
  // same probability of <span class="hljs-built_in">any</span> <span class="hljs-keyword">number</span> <span class="hljs-keyword">in</span> interval
}

<span class="hljs-built_in">float</span> random_jitter(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> N, <span class="hljs-built_in">float</span> a, <span class="hljs-built_in">float</span> b) {
  <span class="hljs-built_in">float</span> random = (i + random_uniform()) / N;
  <span class="hljs-keyword">return</span> a + random * (b-a);
}</code></pre><p>

Jittered sampling can easily be combined with importance sampling (and multiple importance sampling). For importance sampling we can think of it like this. Lets say we want to do 16 samples. For sample 5 we get a random number \(u\) between 0 and 1. Now we could either convert this directly into a x-value using \(u * interval\_width\) or we could also feed it into an importance sampling scheme to get a x-value out. Both works.

</p><p>

<center><div class="image" style=""><a  href="images/mc_is_bars.svg" target="_blank"><img class="markdeep" src="images/mc_is_bars.svg" /></a ><div class="imagecaption">Function f(x) adjusted intervals (larger where function is large).</div></div></center>

</p><p>

with one sample in each interval.

</p><pre class="listing tilde"><code><span class="hljs-keyword">float</span> random_jitter_importance(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> N, ..., <span class="hljs-keyword">float</span> *p) {
  <span class="hljs-keyword">float</span> <span class="hljs-built_in">random</span> = (i + random_uniform()) / N;
  <span class="hljs-built_in">return</span> importance_sample_f(<span class="hljs-built_in">random</span>, ..., p);
}</code></pre><p>

Note that when using importance sampling we must involve the probability of choosing the returned \(x\)-value. This is handled by the importance sampling itself. Jittering does not change the probability since each point is chosen with a probability \(\frac{1}{N}\).

</p><p>

When using jittered sampling it is natural to think of estimating in <em class="asterisk">passes</em>. This is because we need to finish all samples in a pass (here 16) before we are unbiased. For the second pass we might do 16 more samples, or maybe 64. We can change the amount freely when we are doing a new <em class="asterisk">pass</em>. But we need to finish each pass!

</p>
<a class="target" name="references">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>References</h1>
<p>



<ul>
<li class="asterisk">Multiple Importance Sampling
<ul>
  <li class="asterisk"><a href="https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf">Veach thesis</a>
</li></ul>
<li class="asterisk">Jittered sampling
<ul>
  <li class="asterisk"><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15462-s15/www/lec_slides/p51-cook.pdf" class="url">http://www.cs.cmu.edu/afs/cs/academic/class/15462-s15/www/lec_slides/p51-cook.pdf</a>
</li>
  <li class="asterisk"><a href="https://graphics.pixar.com/library/MultiJitteredSampling/paper.pdf" class="url">https://graphics.pixar.com/library/MultiJitteredSampling/paper.pdf</a></li></ul></li></ul>

</p>
<a class="target" name="about">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>About</h1>
<p>


For contact information and license see my main equation text <a href="https://www.breakin.se/equations" class="url">https://www.breakin.se/equations</a>

</p>
<a class="target" name="credits">&nbsp;</a><a class="target" name="toc6.1">&nbsp;</a><h2>Credits</h2>
<p>


Thanks to <a href="https://twitter.com/Atrix256">Alan Wolfe</a> for comments on an early draft of the MIS-section.
Formatting using <a href="https://casual-effects.com/markdeep/">Markdeep</a> by <a href="https://casual-effects.com/markdeep/#credits">Morgan McGuire</a>.

</p><p>

</p></span>
		</div>
	</body>
</html>